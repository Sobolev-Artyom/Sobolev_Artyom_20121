# Листинг 8_1

###  
Функция получает два списка. В каждом списке не должно быть дубликатов.
Функция возвращает:
1) Количество элементов, присутствующих в обоих списках
2) Количество элементов, присутствующих только в одном списке
3) Количество оставшихся элементов в list1 после извлечения элементов из list2
4) Количество оставшихся элементов в list2 после извлечения элементов из list1

```py
def main():
    def abc(list1,list2):
        a =set(list1)
        b =set(list2)
        ans1 = a.intersection(b)
        ans2 = a.symmetric_difference(b)
        ans3 = a.difference(b)
        ans4 = b.difference(a)
        return (print(len(ans1),len(ans2),len(ans3),len(ans4)))

if __name__ == "__main__":
    list1,list2 = [0, 33, 37, 6, 10, 44, 13, 47, 16, 18, 22, 25],[1, 38, 48, 8, 41, 7, 12, 47, 16, 40, 20, 23, 25]
    print(list1,list2)
```
## Мой результат выполнения программы

____

# Листинг 8_2

Функция получает список элементов. Любой элемент может встречаться более одного раза.
Вернуть количество подмножеств, не содержащих повторяющихся элементов, не включая пустое множество. И сами подмножества.

```py
def main():
    import itertools
    i = []
    stuff = [1,2,3]
    for t in range(1,len(stuff)+1):
        for subset in itertools.combinations(stuff,t):
            f = set(subset)
            i.append(f)
    print(i,len(i))

   
if __name__ =='__main__':
```
## Мой результат выполнения программы

____

# Листинг 8_3

У вас подарок, состоящий из 4-х конфет, и каждая конфета имеет свой цвет: red, green, blue, white, так же вас есть три одинаковых пакета для распределения конфет.
Задача создать функцию, которую будет находить и возвращать количество данных комбинаций. Данная функция принимает два целочисленных аргументы: Candies (количество конфет) и Packages(количество пакетов) .  Если Packeges>Candies, то вернуть “No solution”

```py

